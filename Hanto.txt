-- // STEALTH PERSISTENCE CONFIG (SECURE) //
local JSON = game:GetService("HttpService")
local FOLDER_LEVEL_1 = ".shared_assets"
local FOLDER_LEVEL_2 = ".shared_assets/rob_cache"
local FILE_PATH = ".shared_assets/rob_cache/metadata.db"

local function initializeStealthPath()
    if not isfolder(FOLDER_LEVEL_1) then makefolder(FOLDER_LEVEL_1) end
    if not isfolder(FOLDER_LEVEL_2) then makefolder(FOLDER_LEVEL_2) end
end
initializeStealthPath()

local function getSavedData()
    local success, content = pcall(readfile, FILE_PATH)
    if success then
        local ok, decoded = pcall(function() return JSON:JSONDecode(content) end)
        if ok then return decoded end
    end
    return {Attempts = 0, LockTime = 0, Verified = false}
end

local function saveFileData(attempts, lockTime, verified)
    pcall(writefile, FILE_PATH, JSON:JSONEncode({
        Attempts = attempts, 
        LockTime = lockTime, 
        Verified = verified,
        LastUpdate = os.time()
    }))
end

-- // INITIAL SECURITY CHECK //
local currentData = getSavedData()
local p = game.Players.LocalPlayer

if os.time() < currentData.LockTime then
    local timeLeft = currentData.LockTime - os.time()
    -- UPDATED: Removed leading newline, added trailing newlines to sit higher
    p:Kick("[ATTEMPT EXCEEDED!]\nAccess Denied: System Locked.\nCooldown Active: " .. timeLeft .. "s\n\n\n\n\n")
    return 
elseif currentData.Attempts >= 3 then
    currentData.Attempts = 0
    saveFileData(0, 0, false)
end

-- // CORE CONFIG //
local CREATOR_ID = 1740176503 
local ts = game:GetService("TweenService")
local rs = game:GetService("RunService")
local cam = workspace.CurrentCamera
local SCRIPT_KEY = "Hanto"
local MAX_ATTEMPTS = 3
local TIMEOUT_DURATION = 60

-- // THEME //
local isCreator = (p.UserId == CREATOR_ID)
local MAIN_COLOR = isCreator and Color3.fromRGB(170, 0, 255) or Color3.fromRGB(0, 255, 150)
local MAIN_COLOR_HEX = isCreator and "rgb(170,0,255)" or "rgb(0,255,150)"
local PANEL_BG = isCreator and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(15, 15, 15)
local TEXT_COLOR = isCreator and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
local BTN_BG = isCreator and Color3.fromRGB(230, 230, 230) or Color3.fromRGB(30, 30, 30)
local COOL = Enum.Font.Code
local STATUS_ICON = isCreator and "üÉè" or "üçè"

-- // STATE //
local currentLoopID = tick()
_G.HantoLoopID = currentLoopID
local trailActive, auraActive, coinActive, tracerActive = false, false, false, false
local trailWidths, auraRanges = {0.5, 1.5, 3, 5}, {10, 20, 40, 60}
local currentTrailIdx, currentAuraIdx = 1, 1
local tracers = {}
local activeNotifications = {}

-- // PASSIVE ANTI-CAMP BYPASS //
local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    if not checkcaller() and tostring(self) == "AntiCampEvent" and method == "FireServer" then
        return nil
    end
    return oldNamecall(self, ...)
end)
setreadonly(mt, true)

-- // UI CLEANUP (ENHANCED) //
local function CleanUI()
    for _, v in pairs(game.CoreGui:GetChildren()) do if v.Name:find("Hanto") then v:Destroy() end end
    if game.Lighting:FindFirstChild("HantoBlur") then game.Lighting.HantoBlur:Destroy() end
    
    if _G.HantoTracers then
        for _, obj in pairs(_G.HantoTracers) do
            if obj.Line then obj.Line:Remove() end
            if obj.Text then obj.Text:Remove() end
        end
    end
    _G.HantoTracers = tracers
end
CleanUI()

-- // TRACER SYSTEM //
local function createTracer(obj)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y)
    line.Color = MAIN_COLOR
    line.Thickness = 1
    line.Transparency = 1

    local text = Drawing.new("Text")
    text.Visible = false
    text.Color = Color3.new(1, 1, 1)
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Font = 2

    tracers[obj] = {Line = line, Text = text}
end

local function updateTracers()
    local map = workspace:FindFirstChild("CurrentMap")
    local targets = {}
    
    if tracerActive and map then
        local folders = {map:FindFirstChild("Enemies"), map:FindFirstChild("BlackholeEnemies")}
        for _, folder in pairs(folders) do
            if folder then
                for _, enemy in pairs(folder:GetChildren()) do
                    table.insert(targets, enemy)
                end
            end
        end

        for _, enemy in pairs(targets) do
            local hrp = enemy:FindFirstChild("HumanoidRootPart") or enemy.PrimaryPart
            if hrp then
                if not tracers[enemy] then createTracer(enemy) end
                local vector, onScreen = cam:WorldToViewportPoint(hrp.Position)
                local data = tracers[enemy]
                
                if onScreen then
                    local dist = math.floor((hrp.Position - cam.CFrame.Position).Magnitude)
                    data.Line.From = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y)
                    data.Line.To = Vector2.new(vector.X, vector.Y)
                    data.Line.Visible = true
                    
                    data.Text.Position = Vector2.new(vector.X, vector.Y + 2)
                    data.Text.Text = string.format("%s [%d studs]", enemy.Name, dist)
                    data.Text.Visible = true
                else
                    data.Line.Visible = false
                    data.Text.Visible = false
                end
            end
        end
        
        for enemy, data in pairs(tracers) do
            if not enemy:IsDescendantOf(workspace) then
                data.Line:Remove()
                data.Text:Remove()
                tracers[enemy] = nil
            end
        end
    else
        for _, data in pairs(tracers) do
            data.Line.Visible = false
            data.Text.Visible = false
        end
    end
end

-- // UTILS //
local function makeDraggable(obj)
    local dragging, dragInput, dragStart, startPos
    obj.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true; dragStart = input.Position; startPos = obj.Position
            input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false end end)
        end
    end)
    obj.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then dragInput = input end end)
    rs.RenderStepped:Connect(function()
        if dragging and dragInput and _G.HantoLoopID == currentLoopID then
            local delta = dragInput.Position - dragStart
            obj.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

local function createVortex(parent, size, pos, theme)
    local container = Instance.new("Frame", parent)
    container.Size, container.Position, container.BackgroundTransparency, container.AnchorPoint = size, pos, 1, Vector2.new(0.5, 0.5)
    local border = Instance.new("Frame", container)
    border.Size, border.Position, border.AnchorPoint, border.BackgroundColor3 = UDim2.new(1, 4, 1, 4), UDim2.new(0.5, 0, 0.5, 0), Vector2.new(0.5, 0.5), Color3.new(1,1,1)
    Instance.new("UICorner", border).CornerRadius = UDim.new(0, 4)
    local grad = Instance.new("UIGradient", border)
    grad.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, theme or MAIN_COLOR), ColorSequenceKeypoint.new(0.5, Color3.new(0,0,0)), ColorSequenceKeypoint.new(1, theme or MAIN_COLOR)})
    local main = Instance.new("Frame", container)
    main.Size, main.Position, main.AnchorPoint, main.BackgroundColor3, main.ZIndex = UDim2.new(1, 0, 1, 0), UDim2.new(0.5, 0, 0.5, 0), Vector2.new(0.5, 0.5), PANEL_BG, 5
    Instance.new("UICorner", main).CornerRadius = UDim.new(0, 4)
    task.spawn(function() local r = 0 while _G.HantoLoopID == currentLoopID and border.Parent do r = r + 4 grad.Rotation = r task.wait() end end)
    return container, main
end

-- // UI INITIALIZATION //
local sg = Instance.new("ScreenGui", game.CoreGui); sg.Name = "HantoHUD"; sg.Enabled = false
local topC = Instance.new("Frame", sg); topC.Size, topC.Position, topC.BackgroundTransparency = UDim2.new(1, 0, 0, 50), UDim2.new(0, 0, 0, -100), 1
local l1 = Instance.new("TextLabel", topC); l1.Size, l1.Position, l1.BackgroundTransparency, l1.RichText, l1.Font, l1.TextSize = UDim2.new(1, 0, 0, 12), UDim2.new(0, 0, 0, 5), 1, true, COOL, 11
l1.Text = string.format('<font color="%s">Hanto!</font> | <font color="%s">AntiCamp bypass & Coin grabber!</font>', MAIN_COLOR_HEX, MAIN_COLOR_HEX)
local l2 = Instance.new("TextLabel", topC); l2.Size, l2.Position, l2.BackgroundTransparency, l2.RichText, l2.Font, l2.TextSize = UDim2.new(1, 0, 0, 12), UDim2.new(0, 0, 0, 18), 1, true, COOL, 9

-- // STACKING NOTIFICATIONS //
local function Notify(text)
    local nH, nC = createVortex(sg, UDim2.new(0, 180, 0, 28), UDim2.new(1.5, 0, 0.9, 0), MAIN_COLOR)
    local lab = Instance.new("TextLabel", nC)
    lab.Size, lab.BackgroundTransparency, lab.Text, lab.TextColor3, lab.Font, lab.TextSize, lab.ZIndex = UDim2.new(1, 0, 1, 0), 1, text, TEXT_COLOR, COOL, 8, 10
    
    table.insert(activeNotifications, nH)
    
    local function reposition()
        for i, note in ipairs(activeNotifications) do
            local targetY = 0.9 - (#activeNotifications - i) * 0.05
            ts:Create(note, TweenInfo.new(0.3), {Position = UDim2.new(0.88, 0, targetY, 0)}):Play()
        end
    end
    reposition()

    task.delay(2.5, function()
        if nH.Parent then
            ts:Create(nH, TweenInfo.new(0.5), {Position = UDim2.new(1.5, 0, nH.Position.Y.Scale, 0)}):Play()
            task.wait(0.5)
            for i, v in ipairs(activeNotifications) do if v == nH then table.remove(activeNotifications, i) break end end
            nH:Destroy()
            reposition()
        end
    end)
end

-- // TAB OPENER & PANEL //
local tH, tC = createVortex(sg, UDim2.new(0, 22, 0, 22), UDim2.new(0.045, 0, 0.12, 0))
local tBtn = Instance.new("TextButton", tC); tBtn.Size, tBtn.BackgroundTransparency, tBtn.Text, tBtn.TextColor3, tBtn.Font, tBtn.TextSize, tBtn.ZIndex = UDim2.new(1, 0, 1, 0), 1, ">", TEXT_COLOR, COOL, 12, 10
tH.Visible = false

local mH, mC = createVortex(sg, UDim2.new(0, 260, 0, 120), UDim2.new(0.5, 0, -0.6, 0)); makeDraggable(mH)
local btnGrid = Instance.new("Frame", mC); btnGrid.Size, btnGrid.Position, btnGrid.BackgroundTransparency, btnGrid.AnchorPoint, btnGrid.ZIndex = UDim2.new(0.92, 0, 0.85, 0), UDim2.new(0.5, 0, 0.5, 0), 1, Vector2.new(0.5, 0.5), 10
local layout = Instance.new("UIGridLayout", btnGrid); layout.CellPadding, layout.CellSize = UDim2.new(0, 8, 0, 8), UDim2.new(0, 115, 0, 28)

tBtn.MouseButton1Click:Connect(function()
    local isOpen = (mH.Position.Y.Scale > 0.1)
    tBtn.Text = isOpen and ">" or "<"
    ts:Create(mH, TweenInfo.new(0.5, Enum.EasingStyle.Quart), {Position = UDim2.new(0.5, 0, isOpen and -0.6 or 0.5, 0)}):Play()
end)

local function makeBtn(txt)
    local b = Instance.new("TextButton", btnGrid); b.BackgroundColor3 = BTN_BG; b.Text, b.TextColor3, b.Font, b.TextSize, b.ZIndex = txt, TEXT_COLOR, COOL, 8, 10
    Instance.new("UICorner", b).CornerRadius = UDim.new(0, 4); Instance.new("UIStroke", b).Color = MAIN_COLOR
    return b
end

local btnCoin = makeBtn("Coins: OFF")
local btnTracer = makeBtn("Dist. & Tracer: OFF")
local btnAura = makeBtn("Aura: OFF")
local btnAuraSize = makeBtn("Aura Size: 1")
local btnTrail = makeBtn("Trail: OFF")
local btnTrailSize = makeBtn("Trail Size: 1")

btnCoin.MouseButton1Click:Connect(function() coinActive = not coinActive; btnCoin.Text = "Coins: "..(coinActive and "ON" or "OFF"); Notify(coinActive and "Coin Magnet ON" or "Coin Magnet OFF") end)
btnTracer.MouseButton1Click:Connect(function() tracerActive = not tracerActive; btnTracer.Text = "Dist. & Tracer: "..(tracerActive and "ON" or "OFF"); Notify("Enemy Tracers: "..(tracerActive and "ON" or "OFF")) end)
btnAura.MouseButton1Click:Connect(function() auraActive = not auraActive; btnAura.Text = "Aura: "..(auraActive and "ON" or "OFF"); Notify("Aura: "..(auraActive and "ON" or "OFF")) end)
btnTrail.MouseButton1Click:Connect(function() trailActive = not trailActive; btnTrail.Text = "Trail: "..(trailActive and "ON" or "OFF"); Notify("Trail: "..(trailActive and "ON" or "OFF")) end)
btnAuraSize.MouseButton1Click:Connect(function() currentAuraIdx = (currentAuraIdx % #auraRanges) + 1; btnAuraSize.Text = "Aura Size: "..currentAuraIdx; Notify("Range: "..auraRanges[currentAuraIdx]) end)
btnTrailSize.MouseButton1Click:Connect(function() currentTrailIdx = (currentTrailIdx % #trailWidths) + 1; btnTrailSize.Text = "Trail Size: "..currentTrailIdx; Notify("Width: "..trailWidths[currentTrailIdx]) end)

-- // DENIAL SYSTEM //
local function DenyAccess()
    saveFileData(MAX_ATTEMPTS, os.time() + TIMEOUT_DURATION, false)
    CleanUI()
    local dG = Instance.new("ScreenGui", game.CoreGui); dG.Name = "HantoDenied"; dG.IgnoreGuiInset = true; dG.DisplayOrder = 999
    local BG_Layer = Instance.new("Frame", dG); BG_Layer.Size, BG_Layer.BackgroundColor3, BG_Layer.BorderSizePixel, BG_Layer.ZIndex = UDim2.new(1, 0, 1, 0), Color3.new(0, 0, 0), 0, 1
    local _, dC = createVortex(dG, UDim2.new(0, 320, 0, 180), UDim2.new(0.5, 0, 0.5, 0), Color3.new(1, 0, 0))
    dC.Parent.ZIndex = 2
    local msg = Instance.new("TextLabel", dC); msg.Size, msg.Position, msg.AnchorPoint, msg.BackgroundTransparency, msg.TextColor3, msg.Font, msg.TextSize, msg.RichText, msg.ZIndex = UDim2.new(0.9, 0, 0.9, 0), UDim2.new(0.5, 0, 0.5, 0), Vector2.new(0.5, 0.5), 1, Color3.new(1, 1, 1), COOL, 14, true, 15
    for i = 5, 1, -1 do
        msg.Text = '<font color="rgb(255,0,0)" size="20"><b>ACCESS DENIED</b></font><br/><br/>Attempts Exceeded.<br/>System locked for 1 minute.<br/><br/>Kicking in: ' .. i .. 's'
        task.wait(1)
    end
    -- UPDATED: Removed leading newline, added trailing newlines to sit higher
    p:Kick("Access Denied.\n\n\n\n")
end

-- // INTRO + INITIALIZATION //
task.spawn(function()
    local blur = Instance.new("BlurEffect", game.Lighting); blur.Name = "HantoBlur"; blur.Size = 0
    ts:Create(blur, TweenInfo.new(1.2), {Size = 25}):Play()
    
    local iG = Instance.new("ScreenGui", game.CoreGui); iG.Name = "HantoIntro"
    local iT = Instance.new("TextLabel", iG); iT.Size, iT.Position, iT.BackgroundTransparency, iT.RichText, iT.Font, iT.TextSize = UDim2.new(1,0,1,0), UDim2.new(0,0,0,0), 1, true, COOL, 22
    iT.TextColor3, iT.TextTransparency, iT.Text = Color3.new(1,1,1), 1, 'Made by <font color="'..MAIN_COLOR_HEX..'">Kyo</font>'
    
    ts:Create(iT, TweenInfo.new(1), {TextTransparency = 0}):Play()
    task.wait(1.8)
    ts:Create(iT, TweenInfo.new(1), {TextTransparency = 1}):Play()
    task.wait(0.8)
    iG:Destroy()

    local function finishLoad()
        ts:Create(blur, TweenInfo.new(0.5), {Size = 0}):Play()
        sg.Enabled = true; tH.Visible = true
        ts:Create(topC, TweenInfo.new(0.8), {Position = UDim2.new(0,0,0,0)}):Play()
        mH.Position = UDim2.new(0.5, 0, -0.6, 0)
        tBtn.Text = ">"
        Notify("Welcome back, "..p.DisplayName)
    end

    if isCreator or currentData.Verified then 
        finishLoad() 
    else
        local kG = Instance.new("ScreenGui", game.CoreGui); kG.Name = "HantoKey"
        local _, kC = createVortex(kG, UDim2.new(0, 260, 0, 160), UDim2.new(0.5, 0, 0.5, 0))
        local kTitle = Instance.new("TextLabel", kC); kTitle.Size, kTitle.BackgroundTransparency, kTitle.TextColor3, kTitle.Font, kTitle.TextSize, kTitle.ZIndex = UDim2.new(1,0,0,30), 1, TEXT_COLOR, COOL, 11, 10
        kTitle.Text = "Attempts: " .. currentData.Attempts .. " / " .. MAX_ATTEMPTS
        local kInput = Instance.new("TextBox", kC); kInput.Size, kInput.Position, kInput.BackgroundColor3, kInput.TextColor3, kInput.PlaceholderText, kInput.ZIndex = UDim2.new(0.8, 0, 0, 35), UDim2.new(0.5, 0, 0.4, 0), BTN_BG, Color3.new(1,1,1), "Enter Key...", 10; kInput.AnchorPoint = Vector2.new(0.5, 0.5); Instance.new("UICorner", kInput)
        local kCheck = Instance.new("TextButton", kC); kCheck.Size, kCheck.Position, kCheck.BackgroundColor3, kCheck.Text, kCheck.TextColor3, kCheck.ZIndex = UDim2.new(0.8, 0, 0, 30), UDim2.new(0.5, 0, 0.65, 0), MAIN_COLOR, "VERIFY", Color3.new(0,0,0), 10; kCheck.AnchorPoint = Vector2.new(0.5, 0.5); Instance.new("UICorner", kCheck)
        
        local debounce = false
        kCheck.MouseButton1Click:Connect(function()
            if debounce then return end
            local cleanedInput = string.gsub(kInput.Text, "%s+", "")

            if cleanedInput == "" then
                debounce = true; kInput.Text = ""; kInput.PlaceholderText = "CAN'T BE EMPTY!"; task.wait(1); kInput.PlaceholderText = "Enter Key..."; debounce = false; return
            end

            if cleanedInput == SCRIPT_KEY then 
                saveFileData(0, 0, true); kG:Destroy(); finishLoad()
            else
                debounce = true; currentData.Attempts = currentData.Attempts + 1; saveFileData(currentData.Attempts, 0, false)
                kTitle.Text = "Attempts: " .. currentData.Attempts .. " / " .. MAX_ATTEMPTS
                kInput.Text = ""; kInput.PlaceholderText = "WRONG KEY!"
                if currentData.Attempts >= MAX_ATTEMPTS then kG:Destroy(); DenyAccess() else task.wait(1); kInput.PlaceholderText = "Enter Key..."; debounce = false end
            end
        end)
    end
end)

-- // AGGRESSIVE CORE LOOP //
task.spawn(function()
    while _G.HantoLoopID == currentLoopID do
        pcall(function()
            local char = p.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if getnilinstances then
                for _, v in next, getnilinstances() do
                    if v.Name == "PoisonArea" then v:Destroy() end
                end
            end
            
            local playerGui = p:FindFirstChild("PlayerGui")
            if playerGui then
                local targets = {"AntiCampWarningGui", "Vignette", "VignetteCamp"}
                for _, name in pairs(targets) do
                    local ui = playerGui:FindFirstChild(name)
                    if ui then ui:Destroy() end
                end
            end

            local dt = rs.RenderStepped:Wait()
            local fps = math.floor(1/dt)
            local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
            l2.Text = string.format('<font color="%s">Ping: %dms</font> | <font color="%s">FPS: %d</font> | <font color="%s">User: @%s %s</font>', MAIN_COLOR_HEX, ping, MAIN_COLOR_HEX, fps, MAIN_COLOR_HEX, p.Name, STATUS_ICON)
            
            updateTracers()

            if hrp then
                local l = hrp:FindFirstChild("HantoL") or Instance.new("PointLight", hrp); l.Name = "HantoL"
                l.Enabled, l.Range, l.Color, l.Brightness = auraActive, auraRanges[currentAuraIdx], MAIN_COLOR, 4 
                
                local tr = hrp:FindFirstChild("HantoTrail")
                if not tr then
                    local a0 = Instance.new("Attachment", hrp); a0.Name = "HantoA0"; a0.Position = Vector3.new(0, 1.2, 0)
                    local a1 = Instance.new("Attachment", hrp); a1.Name = "HantoA1"; a1.Position = Vector3.new(0, -1.2, 0)
                    tr = Instance.new("Trail", hrp); tr.Name = "HantoTrail"
                    tr.Attachment0, tr.Attachment1 = a0, a1
                    tr.Color = ColorSequence.new(MAIN_COLOR)
                    tr.Lifetime = 0.5
                end
                tr.Enabled = trailActive
                tr.WidthScale = NumberSequence.new(trailWidths[currentTrailIdx])
                
                if coinActive then
                    local targetFolders = {workspace:FindFirstChild("CoinsFolder"), workspace:FindFirstChild("SoulCoinsFolder")}
                    for _, folder in pairs(targetFolders) do
                        if folder then
                            for _, v in pairs(folder:GetDescendants()) do
                                if v:IsA("BasePart") and (v.Name == "Moneda" or v.Name == "SoulCoin") then
                                    v.Velocity = Vector3.zero
                                    v.RotVelocity = Vector3.zero
                                    v.CanCollide = false
                                    v.CFrame = hrp.CFrame
                                end
                            end
                        end
                    end
                end
            end
        end)
        task.wait(0.01)
    end
end)
